import { css } from "@emotion/react";
import {
	autoUpdate,
	FloatingFocusManager,
	FloatingPortal,
	flip,
	offset,
	type Placement,
	shift,
	useClick,
	useDismiss,
	useFloating,
	useInteractions,
	useMergeRefs,
	useRole,
} from "@floating-ui/react";
import {
	cloneElement,
	createContext,
	type Dispatch,
	forwardRef,
	type HTMLProps,
	isValidElement,
	type ReactNode,
	type SetStateAction,
	useContext,
	useMemo,
	useState,
} from "react";

interface PopoverOptions {
	initialOpen?: boolean;
	placement?: Placement;
	modal?: boolean;
	open?: boolean;
	onOpenChange?: (open: boolean) => void;
}

const defaultButton = css`
  color: blue;
  padding: 0;
  border-radius: 4px;
`;

export function usePopover({
	initialOpen = false,
	placement = "top",
	modal,
	open: controlledOpen,
	onOpenChange: setControlledOpen,
}: PopoverOptions = {}) {
	const [uncontrolledOpen, setUncontrolledOpen] = useState(initialOpen);
	const [labelId, setLabelId] = useState<string | undefined>();
	const [descriptionId, setDescriptionId] = useState<string | undefined>();

	const open = controlledOpen ?? uncontrolledOpen;
	const setOpen = setControlledOpen ?? setUncontrolledOpen;

	const data = useFloating({
		placement,
		open,
		onOpenChange: setOpen,
		whileElementsMounted: autoUpdate,
		middleware: [
			offset(5),
			flip({
				crossAxis: placement.includes("-"),
				fallbackAxisSideDirection: "end",
				padding: 5,
			}),
			shift({ padding: 5 }),
		],
	});

	const context = data.context;

	const click = useClick(context, {
		enabled: controlledOpen == null,
	});
	const dismiss = useDismiss(context);
	const role = useRole(context);

	const interactions = useInteractions([click, dismiss, role]);

	return useMemo(
		() => ({
			open,
			setOpen,
			...interactions,
			...data,
			modal,
			labelId,
			descriptionId,
			setLabelId,
			setDescriptionId,
		}),
		[open, setOpen, interactions, data, modal, labelId, descriptionId],
	);
}

type ContextType =
	| (ReturnType<typeof usePopover> & {
			setLabelId: Dispatch<SetStateAction<string | undefined>>;
			setDescriptionId: Dispatch<SetStateAction<string | undefined>>;
	  })
	| null;

const PopoverContext = createContext<ContextType>(null);

export const usePopoverContext = () => {
	const context = useContext(PopoverContext);

	if (context == null) {
		throw new Error("Popover components must be wrapped in <Popover />");
	}

	return context;
};

export function Popover({
	children,
	modal = false,
	...restOptions
}: {
	children: ReactNode;
} & PopoverOptions) {
	const popover = usePopover({ modal, ...restOptions });
	return (
		<PopoverContext.Provider value={popover}>
			{children}
		</PopoverContext.Provider>
	);
}

interface PopoverTriggerProps {
	children: ReactNode;
	asChild?: boolean;
}

export const PopoverTrigger = forwardRef<
	HTMLElement,
	HTMLProps<HTMLElement> & PopoverTriggerProps
>(function PopoverTrigger({ children, asChild = false, ...props }, propRef) {
	const context = usePopoverContext();
	// biome-ignore lint/suspicious/noExplicitAny: allow any children
	const childrenRef = (children as any).ref;
	const ref = useMergeRefs([context.refs.setReference, propRef, childrenRef]);

	// `asChild` allows the user to pass any element as the anchor
	if (asChild && isValidElement(children)) {
		return cloneElement(
			children,
			context.getReferenceProps({
				ref,
				...props,
				...children.props,
				"data-state": context.open ? "open" : "closed",
			}),
		);
	}

	return (
		<button
			ref={ref}
			type="button"
			data-state={context.open ? "open" : "closed"}
			css={defaultButton}
			{...context.getReferenceProps(props)}
		>
			{children}
		</button>
	);
});

export const PopoverContent = forwardRef<
	HTMLDivElement,
	HTMLProps<HTMLDivElement>
>(function PopoverContent({ style, ...props }, propRef) {
	const { context: floatingContext, ...context } = usePopoverContext();
	const ref = useMergeRefs([context.refs.setFloating, propRef]);

	if (!floatingContext.open) return null;

	return (
		<FloatingPortal>
			<FloatingFocusManager context={floatingContext} modal={context.modal}>
				<div
					ref={ref}
					style={{ ...context.floatingStyles, ...style }}
					{...context.getFloatingProps(props)}
				>
					{props.children}
				</div>
			</FloatingFocusManager>
		</FloatingPortal>
	);
});
